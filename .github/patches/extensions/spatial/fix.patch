diff --git a/src/spatial/index/rtree/rtree_index.hpp b/src/spatial/index/rtree/rtree_index.hpp
index 3462613..126f220 100644
--- a/src/spatial/index/rtree/rtree_index.hpp
+++ b/src/spatial/index/rtree/rtree_index.hpp
@@ -34,7 +34,7 @@ public:
 		return std::move(res);
 	}
 
-	static unique_ptr<PhysicalOperator> CreatePlan(PlanIndexInput &input);
+	static PhysicalOperator &CreatePlan(PlanIndexInput &input);
 
 public:
 	//! Called when data is appended to the index. The lock obtained from InitializeLock must be held
diff --git a/src/spatial/index/rtree/rtree_index_create_logical.cpp b/src/spatial/index/rtree/rtree_index_create_logical.cpp
index 9c891e3..a2f7448 100644
--- a/src/spatial/index/rtree/rtree_index_create_logical.cpp
+++ b/src/spatial/index/rtree/rtree_index_create_logical.cpp
@@ -39,8 +39,8 @@ void LogicalCreateRTreeIndex::ResolveColumnBindings(ColumnBindingResolver &res,
 	                                             [&](unique_ptr<Expression> *child) { res.VisitExpression(child); });
 }
 
-static unique_ptr<PhysicalOperator> CreateNullFilter(const LogicalOperator &op, const vector<LogicalType> &types,
-                                                     ClientContext &context) {
+static PhysicalOperator &CreateNullFilter(PhysicalPlanGenerator &generator, const LogicalOperator &op,
+                                          const vector<LogicalType> &types, ClientContext &context) {
 	vector<unique_ptr<Expression>> filter_select_list;
 
 	// Filter NOT NULL on the GEOMETRY column
@@ -66,14 +66,13 @@ static unique_ptr<PhysicalOperator> CreateNullFilter(const LogicalOperator &op,
 	// Combine into an AND
 	auto and_expr = make_uniq_base<Expression, BoundConjunctionExpression>(
 	    ExpressionType::CONJUNCTION_AND, std::move(is_not_null_expr), std::move(is_not_empty_expr));
-
 	filter_select_list.push_back(std::move(and_expr));
 
-	return make_uniq<PhysicalFilter>(types, std::move(filter_select_list), op.estimated_cardinality);
+	return generator.Make<PhysicalFilter>(types, std::move(filter_select_list), op.estimated_cardinality);
 }
 
-static unique_ptr<PhysicalOperator>
-CreateBoundingBoxProjection(const LogicalOperator &op, const vector<LogicalType> &types, ClientContext &context) {
+static PhysicalOperator &CreateBoundingBoxProjection(PhysicalPlanGenerator &planner, const LogicalOperator &op,
+                                                     const vector<LogicalType> &types, ClientContext &context) {
 	auto &catalog = Catalog::GetSystemCatalog(context);
 
 	// Get the bounding box function
@@ -96,11 +95,11 @@ CreateBoundingBoxProjection(const LogicalOperator &op, const vector<LogicalType>
 	select_list.push_back(std::move(bbox_expr));
 	select_list.push_back(std::move(rowid_expr));
 
-	return make_uniq<PhysicalProjection>(types, std::move(select_list), op.estimated_cardinality);
+	return planner.Make<PhysicalProjection>(types, std::move(select_list), op.estimated_cardinality);
 }
 
-static unique_ptr<PhysicalOperator> CreateOrderByMinX(const LogicalOperator &op, const vector<LogicalType> &types,
-                                                      ClientContext &context) {
+static PhysicalOperator &CreateOrderByMinX(PhysicalPlanGenerator &planner, const LogicalOperator &op,
+                                           const vector<LogicalType> &types, ClientContext &context) {
 	auto &catalog = Catalog::GetSystemCatalog(context);
 
 	// Get the centroid value function
@@ -130,14 +129,15 @@ static unique_ptr<PhysicalOperator> CreateOrderByMinX(const LogicalOperator &op,
 	vector<BoundOrderByNode> orders;
 	orders.emplace_back(OrderType::ASCENDING, OrderByNullType::NULLS_FIRST, std::move(xmin_expr));
 	vector<idx_t> projections = {0, 1};
-	return make_uniq<PhysicalOrder>(types, std::move(orders), projections, op.estimated_cardinality);
+	return planner.Make<PhysicalOrder>(types, std::move(orders), projections, op.estimated_cardinality);
 }
 
-unique_ptr<PhysicalOperator> RTreeIndex::CreatePlan(PlanIndexInput &input) {
+PhysicalOperator &RTreeIndex::CreatePlan(PlanIndexInput &input) {
 
 	auto &op = input.op;
 	auto &table_scan = input.table_scan;
 	auto &context = input.context;
+	auto &planner = input.planner;
 
 	// generate a physical plan for the parallel index creation which consists of the following operators
 	// table scan - projection (for expression execution) - filter (NOT NULL) - order - create index
@@ -175,38 +175,35 @@ unique_ptr<PhysicalOperator> RTreeIndex::CreatePlan(PlanIndexInput &input) {
 	select_list.push_back(make_uniq<BoundReferenceExpression>(LogicalType::ROW_TYPE, op.info->scan_types.size() - 1));
 
 	// Project the expressions
-	auto projection = make_uniq<PhysicalProjection>(new_column_types, std::move(select_list), op.estimated_cardinality);
-	projection->children.push_back(std::move(table_scan));
+	auto &projection =
+	    planner.Make<PhysicalProjection>(new_column_types, std::move(select_list), op.estimated_cardinality);
+	projection.children.push_back(table_scan);
 
 	// Filter operator for (IS_NOT_NULL) and (NOT ST_IsEmpty) on the geometry column
-	auto null_filter = CreateNullFilter(op, new_column_types, context);
-	null_filter->children.push_back(std::move(projection));
+	auto &null_filter = CreateNullFilter(planner, op, new_column_types, context);
+	null_filter.children.push_back(projection);
 
 	// Project the bounding box and the row ID
 	vector<LogicalType> projected_types = {GeoTypes::BOX_2DF(), LogicalType::ROW_TYPE};
-	auto bbox_proj = CreateBoundingBoxProjection(op, projected_types, context);
-	bbox_proj->children.push_back(std::move(null_filter));
+	auto &bbox_proj = CreateBoundingBoxProjection(planner, op, projected_types, context);
+	bbox_proj.children.push_back(null_filter);
 
 	// Create an ORDER_BY operator to sort the bounding boxes by the xmin value
-	auto physical_order = CreateOrderByMinX(op, projected_types, context);
-	physical_order->children.push_back(std::move(bbox_proj));
+	auto &physical_order = CreateOrderByMinX(planner, op, projected_types, context);
+	physical_order.children.push_back(bbox_proj);
 
 	// Now finally create the actual physical create index operator
-	auto physical_create_index =
-	    make_uniq<PhysicalCreateRTreeIndex>(op, op.table, op.info->column_ids, std::move(op.info),
-	                                        std::move(op.unbound_expressions), op.estimated_cardinality);
-
-	physical_create_index->children.push_back(std::move(physical_order));
-
-	return std::move(physical_create_index);
+	auto &physical_create_index =
+	    planner.Make<PhysicalCreateRTreeIndex>(op, op.table, op.info->column_ids, std::move(op.info),
+	                                           std::move(op.unbound_expressions), op.estimated_cardinality);
+	physical_create_index.children.push_back(physical_order);
+	return physical_create_index;
 }
 
 // TODO: Remove this
-unique_ptr<PhysicalOperator> LogicalCreateRTreeIndex::CreatePlan(ClientContext &context,
-                                                                 PhysicalPlanGenerator &generator) {
-
-	auto table_scan = generator.CreatePlan(std::move(children[0]));
+PhysicalOperator &LogicalCreateRTreeIndex::CreatePlan(ClientContext &context, PhysicalPlanGenerator &planner) {
 
+	auto &table_scan = planner.CreatePlan(*children[0]);
 	auto &op = *this;
 
 	// generate a physical plan for the parallel index creation which consists of the following operators
@@ -235,7 +232,7 @@ unique_ptr<PhysicalOperator> LogicalCreateRTreeIndex::CreatePlan(ClientContext &
 	D_ASSERT(op.info->index_type == RTreeIndex::TYPE_NAME);
 
 	// table scan operator for index key columns and row IDs
-	generator.dependencies.AddDependency(op.table);
+	planner.dependencies.AddDependency(op.table);
 
 	D_ASSERT(op.info->scan_types.size() - 1 <= op.info->names.size());
 	D_ASSERT(op.info->scan_types.size() - 1 <= op.info->column_ids.size());
@@ -255,30 +252,29 @@ unique_ptr<PhysicalOperator> LogicalCreateRTreeIndex::CreatePlan(ClientContext &
 	select_list.push_back(make_uniq<BoundReferenceExpression>(LogicalType::ROW_TYPE, op.info->scan_types.size() - 1));
 
 	// Project the expressions
-	auto projection = make_uniq<PhysicalProjection>(new_column_types, std::move(select_list), op.estimated_cardinality);
-	projection->children.push_back(std::move(table_scan));
+	auto &projection =
+	    planner.Make<PhysicalProjection>(new_column_types, std::move(select_list), op.estimated_cardinality);
+	projection.children.push_back(table_scan);
 
 	// Filter operator for (IS_NOT_NULL) and (NOT ST_IsEmpty) on the geometry column
-	auto null_filter = CreateNullFilter(op, new_column_types, context);
-	null_filter->children.push_back(std::move(projection));
+	auto &null_filter = CreateNullFilter(planner, op, new_column_types, context);
+	null_filter.children.push_back(projection);
 
 	// Project the bounding box and the row ID
 	vector<LogicalType> projected_types = {GeoTypes::BOX_2DF(), LogicalType::ROW_TYPE};
-	auto bbox_proj = CreateBoundingBoxProjection(op, projected_types, context);
-	bbox_proj->children.push_back(std::move(null_filter));
+	auto &bbox_proj = CreateBoundingBoxProjection(planner, op, projected_types, context);
+	bbox_proj.children.push_back(null_filter);
 
 	// Create an ORDER_BY operator to sort the bounding boxes by the xmin value
-	auto physical_order = CreateOrderByMinX(op, projected_types, context);
-	physical_order->children.push_back(std::move(bbox_proj));
+	auto &physical_order = CreateOrderByMinX(planner, op, projected_types, context);
+	physical_order.children.push_back(bbox_proj);
 
 	// Now finally create the actual physical create index operator
-	auto physical_create_index =
-	    make_uniq<PhysicalCreateRTreeIndex>(op, op.table, op.info->column_ids, std::move(op.info),
-	                                        std::move(op.unbound_expressions), op.estimated_cardinality);
-
-	physical_create_index->children.push_back(std::move(physical_order));
-
-	return std::move(physical_create_index);
+	auto &physical_create_index =
+	    planner.Make<PhysicalCreateRTreeIndex>(op, op.table, op.info->column_ids, std::move(op.info),
+	                                           std::move(op.unbound_expressions), op.estimated_cardinality);
+	physical_create_index.children.push_back(physical_order);
+	return physical_create_index;
 }
 
 } // namespace duckdb
diff --git a/src/spatial/index/rtree/rtree_index_create_logical.hpp b/src/spatial/index/rtree/rtree_index_create_logical.hpp
index e960069..2b73e36 100644
--- a/src/spatial/index/rtree/rtree_index_create_logical.hpp
+++ b/src/spatial/index/rtree/rtree_index_create_logical.hpp
@@ -25,7 +25,7 @@ public:
 	void ResolveColumnBindings(ColumnBindingResolver &res, vector<ColumnBinding> &bindings) override;
 
 	// Actually create and plan the index creation
-	unique_ptr<PhysicalOperator> CreatePlan(ClientContext &context, PhysicalPlanGenerator &generator) override;
+	PhysicalOperator &CreatePlan(ClientContext &context, PhysicalPlanGenerator &planner) override;
 
 	void Serialize(Serializer &writer) const override {
 		LogicalExtensionOperator::Serialize(writer);
diff --git a/src/spatial/index/rtree/rtree_index_scan.cpp b/src/spatial/index/rtree/rtree_index_scan.cpp
index 318f414..d9b4dc1 100644
--- a/src/spatial/index/rtree/rtree_index_scan.cpp
+++ b/src/spatial/index/rtree/rtree_index_scan.cpp
@@ -56,7 +56,7 @@ static unique_ptr<GlobalTableFunctionState> RTreeIndexScanInitGlobal(ClientConte
 	}
 
 	// Initialize the storage scan state
-	result->local_storage_state.Initialize(result->column_ids, input.filters.get());
+	result->local_storage_state.Initialize(result->column_ids, context, input.filters);
 	local_storage.InitializeScan(bind_data.table.GetStorage(), result->local_storage_state.local_state, input.filters);
 
 	// Initialize the scan state for the index
